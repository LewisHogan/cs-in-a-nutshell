\documentclass[]{article}

\input{../../common/preamble.tex}

\usepackage{todonotes}
\setlength{\marginparwidth}{2cm}

\title{CS106L - Standard C++ Programming\thanks{Special thanks to everyone at Stanford University for providing freely accessible materials at \href{https://web.stanford.edu/class/cs106l/}{https://web.stanford.edu/class/cs106l/}}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Introduction}

The goals of completing this module are:
\begin{itemize}
    \item Learn what features are out there in C++, and why they exist.
    \item Become comfortable reading C++ documentation
    \item Become familiar with the design philosophy of \emph{modern} C++
\end{itemize}

C++ documentation has a reputation for being "expert-friendly"

\begin{note}
Take a look at the \href{https://en.cppreference.com/w/cpp/container/vector}{vector} class for an example!
\end{note}

\subsection{History of C++}

\begin{minipage}{\linewidth} % Used to ensure that the code block doesn't split across lines
\begin{lstlisting}[language=C++, caption="Some C++ Code", breaklines=false]
#include <iostream>

int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}
\end{minipage}

\begin{lstlisting}[language=C++, caption="Also some C++ Code", breaklines=false]
#include "stdio.h"
#include "stdlib.h"

int main(int argc, char*argv) {
    printf("%s", "Hello, world!\n"); // a C function!
    return EXIT_SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption="Also (technically) some C++ Code", breaklines=false]
#include "stdio.h"
#include "stdlib.h"

int main(int argc, char*argv) {
    asm("sub $0x20,%rsp\n\t"        // assembly code
        "movabs $0x77202c6f6c6c6548,%rax\n\t"
        "mov %rax,(%rsp)\n\t"
        "movl $0x646c726f, 0x8(%rsp)\n\t"
        "movw $0x21, 0xc(%rsp)\n\t"
        "movb $0x0,0xd(%rsp)\n\t"
        "leaq (%rsp),%rax\n\t"
        "mov %rax,%rdi\n\t"
        "call __Z6myputsPc\n\t"
        "add $0x20, %rsp\n\t"
    );

    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{C++ History: Assembly}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Hello world in Assembly]
section     .text
global      _start              ;must be declared for linker (ld)

_start:                         ;tell linker entry point

    mov     edx, len            ;message length
    mov     ecx, msg            ;message to write
    mov     ebc,1               ;file descriptor (stdout)
    mov     eax,4               ;system call number (sys_write)
    int     0x80                ;call kernel
    mov     eax,1               ;system call number (sys_exit)
    int     0x80                ;call kernel

.section    data
msg     db 'Hello, world',0xa   ;our dear string
len     equ $ - msg             ;length of our dear string
\end{lstlisting}
\end{minipage}

\begin{question}
    There are benefits to using Assembly:
\begin{itemize}
    \item Unbelieveably simple instructions
    \item Extremely fast (when well-written)
    \item Complete control over the program
\end{itemize}
So why don't we use Assembly all the time?
\end{question}

\begin{answer}
There are some major drawbacks to using Assembly:
\begin{itemize}
    \item A lot of code is needed to do simple tasks
    \item It can be very hard to understand
    \item Extremely unportable (hard to make work across all systems)
\end{itemize}
\end{answer}

\subsection{Invention of C}

Computers can only understand assembly (once assembled).

However source code can be written in more intuitive languages, after which a program can be used to convert it into assembly.

\begin{definition}
    A program that converts source code into assembly is called a compiler.
\end{definition}

T\&R created C in 1972, to much acclaim.
C was a language that made it easy to write code that was fast, simple and cross platform.

C was popular because it was simple, but this simplicity presented weaknesses:
\begin{itemize}
    \item No \emph{objects} or \emph{classes}
    \item It's difficult to write code that works \emph{generically}
    \item Tedious when writing \emph{large} programs
\end{itemize}

In 1983, the beginnings of C++ were created by Bjarne Stroustrup, who wanted a language that was fast, simple to use, cross platform and had high level features.

\todo[inline]{Figure out how to insert a timeline showing C with classes all the way to C++20, and if I should just use an image or somehow make it in \LaTeX}

\subsection{Design Philosophy of C++}

There are several design goals in mind for C++:

\begin{itemize}
    \item Allow the programmer full control, responsibility and choice if they want it.
    \item Express ideas and intent directly in code.
    \item Enforce safety at compile time whenever possible.
    \item Do not waste time or space
    \item Compartmentalize messy constructs
\end{itemize}

C++ is multi-paradigm language, designed with the intention to allow expression of ideas and intent directly in code. By focusing on safety, efficiency and abstraction these goals can be achieved.

\subsection{Compilation}

There are 4 key steps in the compilation process:
\begin{enumerate}
    \item Preprocessor - Deals with \#include, \#define and other directives
    \item Compiler - Converts C++ source code into assembly
    \item Assembler - Turns assembled code into object code
    \item Linker - Links object files together to make an executable program
\end{enumerate}

\begin{note}
The first 3 steps in the compilation process look at each file individually, it's only at the last step where the output from various files is combined!
\end{note}

The linker checks that every declared function has an implementation, which is why errors commonly show the linker missing symbols or finding duplicate symbols, instead of catching it earlier.

\begin{minipage}{\linewidth}
\begin{exercise}[Compilation at home]
g++ is an open source C++ compiler, Macs and Linux computers should have g++ automatically while on Windows you can download a copy from \href{https://www.cs.odu.edu/~zeil/cs250PreTest/latest/Public/installingACompiler/#installing-the-cygwin-compiler}{here}.

Try to compile the following program:
\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
    using namespace std;
    cout << "Hello, world!" << endl;
    
    return 0;
}
\end{lstlisting}

To compile a C++ program using g++:
\begin{lstlisting}[numbers=none]
    g++ main.cpp otherFile.cpp -o executableFileName
\end{lstlisting}

It's recommended to enable three common compiler flags when compiling (modern) C++ code
\begin{itemize}
    \item -std=c++17 (enable C++17 support)
    \item -g (add debugging information to the output)
    \item -Wall (turn on most compiler warnings)
\end{itemize}
\end{exercise}
\begin{solution}[Compilation at home]
    Well done! Once you've completed the compilation and run the program you should have the following output:
    \begin{lstlisting}[numbers=none]
Hello, world!
    \end{lstlisting}
\end{solution}
\end{minipage}


\todo[inline]{Try and find a way to have something similar to lstlisting but for a specific word or phrase with shorter syntax}

\section{Types and Structs}
\subsection{Types}

\begin{definition}
    A statically typed language is a language which requires you to define the types of each variable.
\end{definition}

\begin{minipage}{0.45\linewidth}
    Python
    \begin{lstlisting}[language=Python, numbers=none]
a = 3
b = "test"

def func(c):
    # do something
    \end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\linewidth}
    C++
    \begin{lstlisting}[language=C++, numbers=none]
int a = 3;
string b = "test";

void func(c) {
    // do something
}
    \end{lstlisting}
\end{minipage}

C++ is a statically typed language, which offers several benefits:
\begin{itemize}
    \item Better performance
    \item Easier to understand
    \item Better error checking
\end{itemize}

Static typing also allows for catching errors at compile time.

\begin{minipage}{0.45\linewidth}
    Python
    \begin{lstlisting}[language=Python, numbers=none]
def add_3(x):
    return first + 3
add_3("10") # Returns "103", intentional behaviour or bug?
    \end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\linewidth}
    C++
    \begin{lstlisting}[language=C++, numbers=none]
int add_3(int x) {
    return first + 3;
}
add_3("10"); // Caught as a compile error
    \end{lstlisting}
\end{minipage}

\begin{center}
\begin{tabular}{c c}
    Type & Example Value \\
    \hline
    int & 5 \\
    double & 77.3 \\
    string & "test" \\
    bool & true \\
    size\_t & 5 (only non-negative numbers)

\end{tabular}
\end{center}

\begin{minipage}{\linewidth}
    \begin{exercise}[Match the types]
    \begin{lstlisting}[language=C++, numbers=none]
______ a = "test";
______ b = 3.2 * 5 - 1;
______ c = 5 / 2;

______ d(int foo) { return foo / 2; }
______ e(double foo) { return foo / 2; }
______ f(double foo) { return int(foo / 2); }

______ g(double c) { 
    std::cout << c << std::endl;    
}
\end{lstlisting}
\end{exercise}
\end{minipage}

\begin{minipage}{\linewidth}
    \begin{solution}[Match the types]
        \begin{lstlisting}[language=C++, numbers=none]
string a = "test";
double b = 3.2 * 5 - 1;
int c = 5 / 2;

int d(int foo) { return foo / 2; }
double e(double foo) { return foo / 2; }
int f(double foo) { return int(foo / 2); }

void g(double c) { 
    std::cout << c << std::endl;    
}
\end{lstlisting}
    \end{solution}
\end{minipage}

\subsection{Overloading}

\begin{definition}
    Overloading is when there are multiple functions with the same name, but a different call signature.
\end{definition}

\begin{lstlisting}[language=C++]
double func(int x) {
    return (double) x + 3; // cast int -> double 
}

double func(double x) {
    return x * 3;
}

func(2); // uses the first implementation
func(2.0); // uses the second
\end{lstlisting}

\begin{question}
    Can you tell what the output of func(2) and func(2.0) are?
\end{question}

\begin{answer}
func(2) will return 5.0 while func(2.0) will return 15.0
\end{answer}

\subsection{Structs}

Sometimes we want to group data together, or have a function return multiple things.

\begin{lstlisting}[language=C++]
_____ getStudentWithID(int id) {
    // how can we return the student's name, home county and age when we can only return one type?
}

// python:
// return ("lewis", "essex", 23)
\end{lstlisting}

\begin{definition}
    A struct is a group of named variables \emph{which each have their own type}
\end{definition}

\todo{Check the struct example works correctly}
\begin{lstlisting}[language=C++]
struct Student {
    string name; // these are fields
    string county;
    int age;
}

Student s;
s.name = "Lewis"; // the . operator is used to access fields
s.county = "Essex";
s.age = 23;
\end{lstlisting}

Grouping information together (via structs) is a really powerful tool, it can allow for passing or returning information around together.

\begin{lstlisting}[language=C++]
void printStudentInfo(Student student) {
    cout << student.name << " from " << student.county;
    cout << " (" << student.age <<  ")" << endl;
}
\end{lstlisting}

\begin{note}
There is a syntax called Abbreviated Struct Notation which makes it easy to quickly make structs.

\begin{lstlisting}[language=C++, numbers=none]
Student s = { "Lewis", "Essex", 23 };
\end{lstlisting}

Order is based on the original struct order.
\end{note}

\subsection{Pairs \& Tuples}

\begin{definition}
    A pair is a struct with two fields.
\end{definition}

\begin{lstlisting}[language=C++]
int main() {
    std::pair<bool, Student> query_result;
    query_result.first = true;
    Student s = query_result.second;
}    
\end{lstlisting}

\begin{note}
    std::pair is a \emph{template}. Any type can be used inside it; the type goes in the \textless\textgreater
\end{note}

A common use case is returning success status and the result.
\begin{lstlisting}[language=C++]
Student lookupStudent(string name){
    Student blank;
    if (notFound(name)) return std::make_pair(false, blank);

    Student result = getStudentWithName(name);
    return std::make_pair(true, result);
}

std::pair<bool, Student> output = lookupStudent("Lewis");
\end{lstlisting}

\begin{note}
    std::make\_pair is a generic way to make a pair without explicitly writing a type!
\end{note}

\begin{definition}
    A \emph{tuple} is a struct with lots of fields.
\end{definition}

\begin{lstlisting}[language=C++]
int main() {
    std::tuple<string, int, int> query_result;
    string name = std::get<1>(query_result);
    int num = std::get<2>(query_result);
}
\end{lstlisting}

\begin{danger}
std::tuple is \emph{uncommon} and won't be referenced much, generally datatypes like std::vector are more useful
\end{danger}

\begin{exercise}[Quadratic Equations]
A general quadratic equation can always be written:
\[
    \textcolor{red}{a}x^2+\textcolor{blue}{b}x+\textcolor{green}{c}=0
\]
The solutions to a general quadractic equation are
\[
    \frac{
        -b\pm \sqrt{b^2-4\textcolor{red}{a}\textcolor{green}{c}}
    }{2\textcolor{red}{a}}
\]
\end{exercise}
\begin{solution}[Quadratic Equations]
One potential implementation of this algorithm is the following:
\begin{lstlisting}[language=C++]
std::pair<bool, std::pair<double, double>> quadratic(int a, int b, int c) {
    double inside = (b * b) - 4*a*c;
    std::pair<double, double> blank;
    if (inside < 0) return std::make_pair(false, blank);

    std::pair<double, double> answer = std::make_pair(
        (-b + sqrt(inside)) / 2,
        (-b - sqrt(inside)) / 2
    );

    return std::make_pair(true, answer);
}
\end{lstlisting}
How does yours compare?

Using this function would be done in the following manner:
\begin{lstlisting}[language=C++]
int main() {
    int a, b, c;
    std::cin >> a >> b >> c; // Grabs input from terminal
    std::pair<bool, std::pair<double, double>> result = quadratic(a, b, c);
    if (result.first) {
        std::pair<double, double> solutions = result.second;
        std::cout << solutions.first << solutions.second << std::endl;
    } else {
        std::cout << "No solutions found!" << std::endl;
    }
}
\end{lstlisting}
\end{solution}

\subsection{Type Deduction}

\begin{definition}
    auto is a keyword that tells the compiler to deduce the type of a variable
\end{definition}

It's important to avoid being ambiguous or the compiler won't be able to decude types using auto.

auto should be used when it makes a solution significantly easier to read and where manually writing the type does not provide much value.

\begin{lstlisting}[language=C++, numbers=none, caption=Writing the full type]
std::pair<bool, std::pair<double, double>> res = quadratic(a, b, c);
\end{lstlisting}

\begin{lstlisting}[language=C++, numbers=none, caption=The same code using auto]
auto res = quadratic(a, b, c);
\end{lstlisting}

\begin{question}
    What are the types for the following detected as by auto?
    \begin{itemize}
        \item 3
        \item 4.3
        \item 'X'
        \item "Hello"
        \item std::make\_pair(3, "Hello")
    \end{itemize}
\end{question}

\begin{answer}
    \begin{itemize}
        \item intdouble
        \item char
        \item char* (a C style string)
        \item std::pair\textless int, char* \textgreater
    \end{itemize}
\end{answer}

\begin{note}
    auto \emph{does not mean that the variable doesn't have a type}
\end{note}

\subsection{Structured Binding}
\begin{definition}
Structured binding lets variables be initialized \emph{directly} from the contents of a struct
\end{definition}
\begin{minipage}{0.5\linewidth}
\begin{lstlisting}[language=C++, caption=Before, numbers=none]
auto p = std::make_pair("s", 5);
string a = s.first;
int b = s.second;
\end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\linewidth}
\begin{lstlisting}[language=C++, caption=After, numbers=none]
auto p = std::make_pair("s", 5);
auto [a, b] = p;
\end{lstlisting}
\end{minipage}

By combining all of these techniques, it is possible to make significantly more readable code:
\begin{lstlisting}[language=C++]
int main() {
    int a, b, c;
    std::cin >> a >> b >> c; // Grabs input from terminal
    auto [found, solutions] = quadratic(a, b, c);
    if (found) {
        auto [x1, x2] = solutions;
        std::cout << x1 << " " << x2 << std::endl;
    } else {
        std::cout << "No solutions found!" << std::endl;
    }
}
\end{lstlisting}

\end{document}