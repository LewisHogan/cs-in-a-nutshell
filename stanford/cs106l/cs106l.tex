\documentclass[]{article}

\input{../../common/preamble.tex}

\usepackage{todonotes}
\setlength{\marginparwidth}{2cm}

\title{CS106L - Standard C++ Programming\thanks{Special thanks to everyone at Stanford University for providing freely accessible materials at \href{https://web.stanford.edu/class/cs106l/}{https://web.stanford.edu/class/cs106l/}}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Introduction}

The goals of completing this module are:
\begin{itemize}
    \item Learn what features are out there in C++, and why they exist.
    \item Become comfortable reading C++ documentation
    \item Become familiar with the design philosophy of \emph{modern} C++
\end{itemize}

C++ documentation has a reputation for being "expert-friendly"

\begin{note}
Take a look at the \href{https://en.cppreference.com/w/cpp/container/vector}{vector} class for an example!
\end{note}

\subsection{History of C++}

\begin{minipage}{\linewidth} % Used to ensure that the code block doesn't split across lines
\begin{lstlisting}[language=C++, caption="Some C++ Code", breaklines=false]
#include <iostream>

int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
\end{lstlisting}
\end{minipage}

\begin{lstlisting}[language=C++, caption="Also some C++ Code", breaklines=false]
#include "stdio.h"
#include "stdlib.h"

int main(int argc, char*argv) {
    printf("%s", "Hello, world!\n"); // a C function!
    return EXIT_SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption="Also (technically) some C++ Code", breaklines=false]
#include "stdio.h"
#include "stdlib.h"

int main(int argc, char*argv) {
    asm("sub $0x20,%rsp\n\t"        // assembly code
        "movabs $0x77202c6f6c6c6548,%rax\n\t"
        "mov %rax,(%rsp)\n\t"
        "movl $0x646c726f, 0x8(%rsp)\n\t"
        "movw $0x21, 0xc(%rsp)\n\t"
        "movb $0x0,0xd(%rsp)\n\t"
        "leaq (%rsp),%rax\n\t"
        "mov %rax,%rdi\n\t"
        "call __Z6myputsPc\n\t"
        "add $0x20, %rsp\n\t"
    );

    return EXIT_SUCCESS;
}
\end{lstlisting}

\subsection{C++ History: Assembly}

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Hello world in Assembly]
section     .text
global      _start              ;must be declared for linker (ld)

_start:                         ;tell linker entry point

    mov     edx, len            ;message length
    mov     ecx, msg            ;message to write
    mov     ebc,1               ;file descriptor (stdout)
    mov     eax,4               ;system call number (sys_write)
    int     0x80                ;call kernel
    mov     eax,1               ;system call number (sys_exit)
    int     0x80                ;call kernel

.section    data
msg     db 'Hello, world',0xa   ;our dear string
len     equ $ - msg             ;length of our dear string
\end{lstlisting}
\end{minipage}

\begin{question}
    There are benefits to using Assembly:
\begin{itemize}
    \item Unbelieveably simple instructions
    \item Extremely fast (when well-written)
    \item Complete control over the program
\end{itemize}
So why don't we use Assembly all the time?
\end{question}

\begin{answer}
There are some major drawbacks to using Assembly:
\begin{itemize}
    \item A lot of code is needed to do simple tasks
    \item It can be very hard to understand
    \item Extremely unportable (hard to make work across all systems)
\end{itemize}
\end{answer}

\subsection{Invention of C}

Computers can only understand assembly (once assembled).

However source code can be written in more intuitive languages, after which a program can be used to convert it into assembly.

\begin{definition}
    A program that converts source code into assembly is called a compiler.
\end{definition}

T\&R created C in 1972, to much acclaim.
C was a language that made it easy to write code that was fast, simple and cross platform.

C was popular because it was simple, but this simplicity presented weaknesses:
\begin{itemize}
    \item No \emph{objects} or \emph{classes}
    \item It's difficult to write code that works \emph{generically}
    \item Tedious when writing \emph{large} programs
\end{itemize}

In 1983, the beginnings of C++ were created by Bjarne Stroustrup, who wanted a language that was fast, simple to use, cross platform and had high level features.

\todo[inline]{Figure out how to insert a timeline showing C with classes all the way to C++20, and if I should just use an image or somehow make it in \LaTeX}

\subsection{Design Philosophy of C++}

There are several design goals in mind for C++:

\begin{itemize}
    \item Allow the programmer full control, responsibility and choice if they want it.
    \item Express ideas and intent directly in code.
    \item Enforce safety at compile time whenever possible.
    \item Do not waste time or space
    \item Compartmentalize messy constructs
\end{itemize}

C++ is multi-paradigm language, designed with the intention to allow expression of ideas and intent directly in code. By focusing on safety, efficiency and abstraction these goals can be achieved.

\subsection{Compilation}

There are 4 key steps in the compilation process:
\begin{enumerate}
    \item Preprocessor - Deals with \#include, \#define and other directives
    \item Compiler - Converts C++ source code into assembly
    \item Assembler - Turns assembled code into object code
    \item Linker - Links object files together to make an executable program
\end{enumerate}

\begin{note}
The first 3 steps in the compilation process look at each file individually, it's only at the last step where the output from various files is combined!
\end{note}

The linker checks that every declared function has an implementation, which is why errors commonly show the linker missing symbols or finding duplicate symbols, instead of catching it earlier.

\begin{minipage}{\linewidth}
\begin{exercise}[Compilation at home]
g++ is an open source C++ compiler, Macs and Linux computers should have g++ automatically while on Windows you can download a copy from \href{https://www.cs.odu.edu/~zeil/cs250PreTest/latest/Public/installingACompiler/#installing-the-cygwin-compiler}{here}.

Try to compile the following program:
\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
    using namespace std;
    cout << "Hello, world!" << endl;
    
    return 0;
}
\end{lstlisting}

To compile a C++ program using g++:
\begin{lstlisting}[numbers=none]
    g++ main.cpp otherFile.cpp -o executableFileName
\end{lstlisting}

It's recommended to enable three common compiler flags when compiling (modern) C++ code
\begin{itemize}
    \item -std=c++17 (enable C++17 support)
    \item -g (add debugging information to the output)
    \item -Wall (turn on most compiler warnings)
\end{itemize}
\end{exercise}
\begin{solution}[Compilation at home]
    Well done! Once you've completed the compilation and run the program you should have the following output:
    \begin{lstlisting}[numbers=none]
Hello, world!
    \end{lstlisting}
\end{solution}
\end{minipage}


\todo[inline]{Try and find a way to have something similar to lstlisting but for a specific word or phrase with shorter syntax}

\section{Types and Structs}
\subsection{Types}

\begin{definition}
    A statically typed language is a language which requires you to define the types of each variable.
\end{definition}

\begin{minipage}{0.45\linewidth}
    Python
    \begin{lstlisting}[language=Python, numbers=none]
a = 3
b = "test"

def func(c):
    # do something
    \end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\linewidth}
    C++
    \begin{lstlisting}[language=C++, numbers=none]
int a = 3;
string b = "test";

void func(c) {
    // do something
}
    \end{lstlisting}
\end{minipage}

C++ is a statically typed language, which offers several benefits:
\begin{itemize}
    \item Better performance
    \item Easier to understand
    \item Better error checking
\end{itemize}

Static typing also allows for catching errors at compile time.

\begin{minipage}{0.45\linewidth}
    Python
    \begin{lstlisting}[language=Python, numbers=none]
def add_3(x):
    return first + 3
add_3("10") # Returns "103", intentional behaviour or bug?
    \end{lstlisting}
\end{minipage}
\begin{minipage}{0.45\linewidth}
    C++
    \begin{lstlisting}[language=C++, numbers=none]
int add_3(int x) {
    return first + 3;
}
add_3("10"); // Caught as a compile error
    \end{lstlisting}
\end{minipage}

\begin{center}
\begin{tabular}{c c}
    Type & Example Value \\
    \hline
    int & 5 \\
    double & 77.3 \\
    string & "test" \\
    bool & true \\
    size\_t & 5 (only non-negative numbers)

\end{tabular}
\end{center}

\begin{minipage}{\linewidth}
    \begin{exercise}[Match the types]
    \begin{lstlisting}[language=C++, numbers=none]
______ a = "test";
______ b = 3.2 * 5 - 1;
______ c = 5 / 2;

______ d(int foo) { return foo / 2; }
______ e(double foo) { return foo / 2; }
______ f(double foo) { return int(foo / 2); }

______ g(double c) { 
    std::cout << c << std::endl;    
}
\end{lstlisting}
\end{exercise}
\end{minipage}

\begin{minipage}{\linewidth}
    \begin{solution}[Match the types]
        \begin{lstlisting}[language=C++, numbers=none]
string a = "test";
double b = 3.2 * 5 - 1;
int c = 5 / 2;

int d(int foo) { return foo / 2; }
double e(double foo) { return foo / 2; }
int f(double foo) { return int(foo / 2); }

void g(double c) { 
    std::cout << c << std::endl;    
}
\end{lstlisting}
    \end{solution}
\end{minipage}

\subsection{Overloading}
\subsection{Structs}
\subsection{Pairs \& Tuples}
\subsection{Type Deduction}
\subsection{Structured Binding}
\end{document}